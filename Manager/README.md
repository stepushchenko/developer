# Manager

### Контроль версий кода в репозитории

**Git flow** <br>
Характеризуется функциональными ветками и несколькими основными. Наработки, относящиеся к конкретной функциональности,
хранятся в соответствующей ветке и вливаются в основную ветку после завершения тестирования новой функции. 
Функциональные ветки могут жить достаточно долго (по несколько месяцев) и основные проблемы начинаются 
при вливании функциональной ветки в основную из-за возможных больших расхождений между ветками.

**Магистральная разработка (Trunk based development)** <br>
Характеризуется частым созданием небольших ответвлений от основной ветки для внесения небольших правок в код 
с последующим вливанием малой ветки в основную. Подход удобен при создании CI/CD и требует наличия тестовых стендов
для обнаружения багов в основной ветке прежде, чем код будет отправлен на продакшен сервер. 



### Объектно ориентированное программирование

**Основные подходы**<br>
- Инкапсуляция (позволяет скрыть реализацию от конечного пользователя и предоставить лишь интерфейс для взаимодействия с объектом)
- Полиморфизм (дополнение функциональности одного абстрактного класса через создание подклассов, которые в итоге дают нужную функциональность BasePageClass и его дочерний класс LoginPageClass)
- Наследование (дополнение функциональности одного абстрактного класса через создание подклассов, которые в итоге дают нужную функциональность BasePageClass и его дочерний класс LoginPageClass)



### Принципы программирования и проектирования (DRY, SOLID, etc)

**DRY**
Don’t repeat yourself.

Не дублируй код.

**KISS**
Keep It Simple Simon.

Принцип проектирования и программирования, при котором простота системы декларируется в качестве основной цели или ценности. 
Убирай из системы все лишние функции и оставь только то, что помогает достичь главной цели. 
- каждый метод должен решать только одну задачу
- если в функциональности есть условия, убедитесь, что вы разнесли реализацию на несколько методов
- методы должны быть небольшими (до 50 строк кода)

**YAGNI**
You Aren't Gonna Need It.

Если функционал не описан в требованиях к системе, то он не должен быть реализован. 

**SOLID**

Single Responsibility Principle (SRP) - Принцип единой ответственности.

Open/Closed Principle (OCP) - Принцип открытия / закрытия.

Liskov Substitution Principle - Принцип замещения Лисков.

Interface Segregation Principle - Принцип разделения интерфейса.

Dependency Inversion Principle - Принцип инверсии зависимостей.


### Паттерны (шаблоны) разработки (Singleton, Adapter, Builder, etc)
Паттерн – это не фрагмент кода, а общая концепция, которая описывает, как решить конкретную повторяющуюся проблему.

**Singleton** (одиночка)

**Декоратор**

**Итератор**

**Adapter**

**Builder**


### Test Management Strategies

**The C4 Test Pyramid**



### Измеряемые метрики в тестировании (Test metrics)

- Текущий прогресс (сколько тестов пройдено и сколько еще предстоит пройти). Чем больше цифра, тем лучше.
- Плотность дефектов (количество дефектов в модуле / количество дефектов в продукте). Чем меньше цифра, тем лучше.
- Повторно открытые дефекты (количество повторно отрытых дефектов / количество дефектов в продукте). Чем меньше цифра, тем лучше.
- Среднее время жизни дефекта
- Соотношение количества пропущенных в продакшн дефектов к количеству всех дефектов в итерации



### Тестовое покрытие (Test Coverage)

**Покрытие требований (Requirements Coverage)** <br>
Тестовое покрытие = (количество требований, проверяемых тест кейсами / общее количество требований) * 100% <br>
Чтобы оптимизировать количество создаваемых тестов, используются техники тест дизайна. <br>

**Покрытие кода (Code Coverage)** <br>
Тестовое покрытие = (кол-ва строк кода, покрытых тестами / общее кол-во строк кода) * 100% <br>
Специализированное ПО, например Atlassian Clover, позволяет проанализировать для каких строк кода тесты есть, а для каких нет. <br>

**Тестовое покрытие на базе анализа потока управления** <br>
Суть в определении путей выполнения кода программного модуля и создания выполняемых тест кейсов для покрытия этих путей.<br>

0. Начальный уровень -> Тестируй все что протестируешь, пользователи протестируют остальное.
1. Покрытие операторов -> Каждый оператор должен быть выполнен как минимум один раз.
2. Покрытие ветвей -> Каждый узел с ветвлением (альтернатива) выполнен как минимум один раз. 
3. Покрытие условий -> Каждое условие, имеющее TRUE и FALSE на выходе, выполнено как минимум один раз.
4. Покрытие условий альтернатив -> Тестовые случаи создаются для каждого условия и альтернативы
5. Покрытие множественных условий -> Достигается покрытие альтернатив, условий и условий альтернатив (Уровни 2, 3 и 4)
6. Покрытие бесконечного числа путей -> Если, в случае зацикливания, количество путей становится бесконечным, допускается существенное их сокращение, ограничивая количество циклов выполнения, для уменьшения числа тестовых случаев.
7. Покрытие путей -> Все пути должны быть проверены